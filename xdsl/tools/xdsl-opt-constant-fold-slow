#!/usr/bin/env python3

import argparse
from xdsl.xdsl_opt_main import xDSLOptMain
from xdsl.pattern_rewriter import RewriteOnceWalker, RewritePattern, PatternRewriter, GreedyRewritePatternApplier, PatternRewriteWalker

from xdsl.dialects.builtin import ModuleOp, IntegerAttr
from xdsl.dialects.arith import Constant, Addi
from xdsl.ir import Operation, MLContext
from xdsl.pattern_rewriter import (GreedyRewritePatternApplier,
                                   PatternRewriter, PatternRewriteWalker,
                                   RewritePattern, op_type_rewrite_pattern)
from dataclasses import dataclass


@dataclass
class BinaryExprRewriter(RewritePattern):

    num_changed_values: int = 0

    def is_integer_literal(self, op: Operation) -> bool:
        return isinstance(op, Constant) and isinstance(op.value, IntegerAttr)

    @op_type_rewrite_pattern
    def match_and_rewrite(  # type: ignore reportIncompatibleMethodOverride
            self, expr: Addi, rewriter: PatternRewriter) -> None:
        if self.is_integer_literal(expr.lhs.op) and self.is_integer_literal(
                expr.rhs.op):
            lhs_value = expr.lhs.op.value.parameters[0].data
            rhs_value = expr.rhs.op.value.parameters[0].data
            result_value = lhs_value + rhs_value

            new_constant = Constant.from_int_constant(result_value,
                                                      expr.results[0].typ)
            rewriter.replace_op(expr, [new_constant])
            self.num_changed_values += 1
        return


@dataclass
class RemoveUnusedRewriter(RewritePattern):

    @op_type_rewrite_pattern
    def match_and_rewrite(self, op: Operation, rewriter: PatternRewriter):
        for r in op.results:
            if len(r.uses) == 0:
                rewriter.erase_matched_op()


# Assign rvalue to lvalue, and delete rvalue contents.
def assign_module_and_delete(lvalue: ModuleOp, rvalue: ModuleOp):
    lregion = lvalue.regions[0]
    rregion = rvalue.regions[0]
    lvalue.regions[0] = rregion
    rregion.parent = lvalue
    lregion.parent = None


def constant_folding(ctx: MLContext, module: ModuleOp) -> None:
    rewriter = BinaryExprRewriter()
    walker = RewriteOnceWalker(rewriter)
    cleanup_walker = RewriteOnceWalker(RemoveUnusedRewriter())

    module_copy = module.clone()
    if not walker.rewrite_module(module_copy):
        return

    assign_module_and_delete(module, module_copy)
    module_copy = module.clone()

    while walker.rewrite_module(module_copy):
        assign_module_and_delete(module, module_copy)
        module_copy = module.clone()
        cleanup_walker.rewrite_module(module)
        cleanup_walker.rewrite_module(module)

    return


def constant_folding_fast(ctx: MLContext, module: ModuleOp) -> None:
    walker = RewriteOnceWalker(BinaryExprRewriter())
    cleanup_walker = RewriteOnceWalker(RemoveUnusedRewriter())

    while walker.rewrite_module(module):
        cleanup_walker.rewrite_module(module)
        cleanup_walker.rewrite_module(module)
        pass
    return


class OptMain(xDSLOptMain):

    def register_all_dialects(self):
        super().register_all_dialects()

    def register_all_passes(self):
        super().available_passes['constant-fold'] = constant_folding
        super().available_passes['constant-fold-fast'] = constant_folding_fast
        super().register_all_passes()

    def register_all_arguments(self, arg_parser: argparse.ArgumentParser):
        super().register_all_arguments(arg_parser)


def __main__():
    xdsl_main = OptMain()
    xdsl_main.run()


if __name__ == "__main__":
    __main__()
