builtin.module() {

  ////////////////////////////////////////////////////////////////////////////////
  //   Define completely custom strategies with the match & rewrite dialects    //
  ////////////////////////////////////////////////////////////////////////////////

  %inline : !strategy = elevate.strategy() {
    ^strategy(%op : !operation):
    %pattern : !pattern = match.pattern() {
      (%apply_op : !operation, %cons_apply_vals : !range<!value>) = pdl.operation() ["name" = "stencil.apply"]
      match.capture(%cons_apply_vals : !range<!value>)
    }
    // automatically using results here should work with ranges as well (i.e. all results are in the range)
    match.match_and_replace(%op : !operation, %pattern : !pattern) {
      ^rewrite(%consumer_apply : !operation, %cons_apply_vals : !range<!value>):
      (%producer_apply : !operation, %access_op_to_inline_at : !operation, %operand_to_inline : !value) = irutils.native_matcher(%consumer_apply : !operation) ["matcher_name" = "match_inlinable"]  
      
      // concat producer and consumer operands
      %producer_operands : !range<!value> = irutils.get_operands(%producer_apply : !operation)
      %consumer_operands : !range<!value> = irutils.get_operands(%consumer_apply : !operation)    
      %new_operands : !range<!value> = irutils.concat(%producer_operands : !range<!value>, %consumer_operands : !range<!value>)

      // concat producer and consumer blockargs
      %producer_args : !range<!value> = irutils.get_block_args(%producer_apply : !operation)
      %consumer_args : !range<!value> = irutils.get_block_args(%consumer_apply : !operation)
      %new_args : !range<!value> = irutils.concat(%producer_args : !range<!value>, %consumer_args : !range<!value>)

      // Get index to inline at
      %consumer_ops : !range<!operation> = irutils.get_nested_ops(%consumer_apply : !operation)
      %inlining_idx : !index = irutils.get_index_of_op_in_range(%access_op_to_inline_at : !operation, %consumer_ops : !range<!operation>)
      %cst0 : !index = arith.constant() ["value" = 0 : !index]
      %cst1 : !index = arith.constant() ["value" = 1 : !index]
      %inlining_idx_plus_one : !index = arith.addi(%inlining_idx : !index, %cst1 : !index)

      // create list of new ops from consumer and producer
      %consumer_ops_first_half : !range<!operation> = irutils.get_nested_ops(%consumer_apply : !operation, %inlining_idx : !index) ["custom_ub" = 1 : !i1]
      %consumer_ops_second_half : !range<!operation> = irutils.get_nested_ops(%consumer_apply : !operation, %inlining_idx_plus_one : !index) ["custom_lb" = 1 : !i1]
      %producer_ops : !range<!operation> = irutils.get_nested_ops(%producer_apply : !operation)
      %new_ops : !range<!operation> = irutils.concat(%consumer_ops_first_half : !range<!operation>, %producer_ops : !range<!operation>, %consumer_ops_second_half : !range<!operation>)

      // create region for the new applyOp
      %custom_merger : !native_handle = irutils.apply_native_rewrite(%producer_apply : !operation, %consumer_apply : !operation, %access_op_to_inline_at : !operation, %operand_to_inline : !value) ["rewriter_name" = "inlining_merger"]
      %new_apply_block : !block = irutils.new_block(%new_args : !range<!value>, %new_ops : !range<!operation>, %custom_merger : !native_handle)
      %new_apply_region : !region = irutils.region_from_blocks(%new_apply_block : !block)

      // create new applyOp
      %result_types : !range<!type> = irutils.get_type(%cons_apply_vals : !range<!value>)
      %attributes : !range<!attribute> = irutils.get_attributes(%consumer_apply : !operation)
      %new_apply_op : !operation = irutils.new_op(%new_operands : !range<!value>, %result_types : !range<!type>, %attributes : !range<!attribute>, %new_apply_region : !region) ["name" = "stencil.Apply"]

      rewrite.return(%new_apply_op : !operation)
    }
  }

  // A simpler implementation of the above inlining rewrite.
  %inline_simplified : !strategy = elevate.strategy() {
    ^strategy(%op : !operation):
    %pattern : !pattern = match.pattern() {



      // (%producer_apply : !operation, %producer_vals : !range<!value>) = pdl.operation() ["name" = "stencil.apply"]
      
      // %producer_val : !value = match.any_in_range(%producer_vals : !range<!value>) []
      (%apply_op : !operation, %cons_apply_vals : !range<!value>) = pdl.operation() ["name" = "stencil.apply"] {
        ^b1(%cons_block_args : !value):
        
          // To continue meaningfully I have to have an implementation stub for any_in_range
          // or implement it actually

            // %idx1 : !index = irutils.get_index(%producer_val : !value)
            // %producer_arg : !value = irutils.get_elem(%cons_block_args : !value, %idx1 : !index)


        //     %cmp = arith.cmpi(%idx1, %idx2, "eq")
        //     match.assert(%cmp)
            
        //     %emptystore =  pdl.operation_with_region "stencil.store"()
        //     match.region.does_not_contain(%emptystore)

        //     //option1
        //     %dynaccess = pdl.operation "stencil.dynaccess"(%producer_arg : !value)
        //     match.region.does_not_contain(%dynaccess)

        //     // option2
        //     %dynaccess_pattern = match.pattern {
        //         pdl.operation "stencil.dynaccess"(%producer_arg : !value)
        //     }
        //     match.region.does_not_contain(%dynaccess_pattern)

        //     //option3 <- this 
        //     match.region.does_not_contain {
        //         pdl.operation "stencil.dynaccess"(%producer_arg : !value)
        //     }

        //     %dynaccess = pdl.operation "stencil.dynaccess"(%producer_arg : !value)
        //     match.region.does_not_contain() {
        //       return %dynaccess
        //     }





        //     %matched_access_op_to_inline_at = pdl.operation "stencil.access"(%producer_arg : !value)
        //     match.capture(%matched_access_op_to_inline_at)
        // }

      }


      // first implement the region stuff




      match.capture(%cons_apply_vals : !range<!value>)
    }
    // TODO: implement support for the following IR so we can perform the matching with the dialect 
    //
  
    // ^b0(%producer_val : !value, %access_op_to_inline_at : !operation):

    // %producer_apply : !operation, %producer_vals : !range<!value> = ir.stencil.apply()
    // %producer_val : !value = match.any_in_range(%producer_vals : !range<!value>)

    // %consumer_apply : !operation = ir.stencil.apply(%producer_val : !value) {
    //   ^b1(%producer_arg : !value):
    //   match.index_equal(%producer_val : !value, %producer_arg : !value)
    //   %matched_access_op_to_inline_at = ir.stencil.access(%producer_arg : !value)

    //   // make this match available in the rewrite region by binding it to a value in the outer scope
    //   irutils.bind(%matched_access_op_to_inline_at, %access_op_to_inline_at)    
    // }

    match.match_and_replace(%op : !operation, %pattern : !pattern) {
      ^rewrite(%consumer_apply : !operation, %cons_apply_vals : !range<!value>):
      (%producer_apply : !operation, %access_op_to_inline_at : !operation, %inlined_operand_result_index : !index) = irutils.native_matcher(%consumer_apply : !operation) ["matcher_name" = "match_inlinable_native_escape"]  

      // concat producer and consumer operands
      %producer_operands : !range<!value> = irutils.get_operands(%producer_apply : !operation)
      %consumer_operands : !range<!value> = irutils.get_operands(%consumer_apply : !operation)    
      %new_operands : !range<!value> = irutils.concat(%producer_operands : !range<!value>, %consumer_operands : !range<!value>)

      // concat producer and consumer blockargs
      %producer_args : !range<!value> = irutils.get_block_args(%producer_apply : !operation)
      %consumer_args : !range<!value> = irutils.get_block_args(%consumer_apply : !operation)
      %new_args : !range<!value> = irutils.concat(%producer_args : !range<!value>, %consumer_args : !range<!value>)

      // Get index to inline at
      %consumer_ops : !range<!operation> = irutils.get_nested_ops(%consumer_apply : !operation)
      %inlining_idx : !index = irutils.get_index_of_op_in_range(%access_op_to_inline_at : !operation, %consumer_ops : !range<!operation>)
      %cst0 : !index = arith.constant() ["value" = 0 : !index]
      %cst1 : !index = arith.constant() ["value" = 1 : !index]
      %inlining_idx_plus_one : !index = arith.addi(%inlining_idx : !index, %cst1 : !index)

      // create list of new ops from consumer and producer
      %producer_ops : !range<!operation> = irutils.get_nested_ops(%producer_apply : !operation)
      // update all existing offsets ops in %producer_ops
      %updated_producer_ops : !range<!operation> = irutils.for_each(%producer_ops : !range<!operation>) {
        ^foreach(%producer_op : !operation):
        // check if producer_op has an offset in its attributes
        %has_offset : !i1 = irutils.has_attribute(%producer_op : !operation) ["attr_name" = "offset"]
        %updated_op : !operation = irutils.if (%has_offset : !i1) {
          // return new producer_op with updated offset
          // %producer_op_old_attrs : !range<!attribute> = irutils.get_attributes(%producer_op : !operation)
          %producer_offset : !attribute = irutils.get_attribute(%producer_op : !operation) ["attr_name" = "offset"]
          %access_op_offset : !attribute = irutils.get_attribute(%access_op_to_inline_at : !operation) ["attr_name" = "offset"]
          %new_offset : !attribute = irutils.array_attr_element_wise(%producer_offset : !attribute, %access_op_offset : !attribute) ["op" = "add"]
          %new_attributes : !range<!attribute> = irutils.attribute_range(%new_offset : !attribute) ["attribute_names"=["offset"]]
          %updated_producer_op : !operation = irutils.from_op(%producer_op : !operation, %new_attributes : !range<!attribute>) []
          irutils.yield(%updated_producer_op : !operation)
        } {
          // because the uses possibly have to be updated to the ops with a new offset
          %updated_producer_op : !operation = irutils.from_op(%producer_op : !operation) []
          irutils.yield(%updated_producer_op : !operation)
        }
        irutils.yield(%updated_op : !operation)
      }

      // replace use of %access_op_to_inline_at : !operation to whatever is in the return value
      %producer_return : !operation = irutils.get_elem(%updated_producer_ops : !range<!operation>) ["index" = -1 : !index]
      %producer_returned_val : !value = irutils.get_operand(%producer_return : !operation, %inlined_operand_result_index : !index)
      %store_result_op : !operation = irutils.get_op(%producer_returned_val : !value)
      %stored_val : !value = irutils.get_operand(%store_result_op : !operation) ["index" = -1 : !index]
      %access_op_to_inline_at_res : !value = irutils.get_results(%access_op_to_inline_at : !operation) ["index" = 0 : !index]
      irutils.replace_uses(%access_op_to_inline_at_res : !value, %stored_val : !value)

      // remove return op (last element) of the updated producer ops
      irutils.remove_element(%updated_producer_ops : !range<!operation>) ["index" = -1 : !index]


      %consumer_ops_first_half : !range<!operation> = irutils.get_nested_ops(%consumer_apply : !operation, %inlining_idx : !index) ["custom_ub" = 1 : !i1]
      %consumer_ops_second_half : !range<!operation> = irutils.get_nested_ops(%consumer_apply : !operation, %inlining_idx_plus_one : !index) ["custom_lb" = 1 : !i1]
      %new_ops : !range<!operation> = irutils.concat(%consumer_ops_first_half : !range<!operation>, %updated_producer_ops : !range<!operation>, %consumer_ops_second_half : !range<!operation>)


      // create region for the new applyOp
      %new_apply_block : !block = irutils.new_block(%new_args : !range<!value>, %new_ops : !range<!operation>)
      %new_apply_region : !region = irutils.region_from_blocks(%new_apply_block : !block)

      // create new applyOp
      %result_types : !range<!type> = irutils.get_type(%cons_apply_vals : !range<!value>)
      %attributes : !range<!attribute> = irutils.get_attributes(%consumer_apply : !operation)
      %new_apply_op : !operation = irutils.new_op(%new_operands : !range<!value>, %result_types : !range<!type>, %attributes : !range<!attribute>, %new_apply_region : !region) ["name" = "stencil.Apply"]

      rewrite.return(%new_apply_op : !operation)
    }
  }

  // The concept of this rerouting rewrite is different from the multipattern in Python. This does not represent
  // the last matching step + rewriting but rather the first matching step, calling into native for the rest
  // and then performing the rewrite
  %reroute : !strategy = elevate.strategy() {
    ^strategy(%op : !operation):
    %pattern : !pattern = match.pattern() {
      (%anchor_op : !operation) = pdl.operation()
    }
    // we have a root "anchor" op (will be func here) and do the actual matching only natively -> matchTopToBottom
    match.match_and_replace(%op : !operation, %pattern : !pattern) {
      ^rewrite(%root : !operation):
      (%producer : !operation, %fst_consumer : !operation, %snd_consumer : !operation) = irutils.native_matcher(%root : !operation) ["matcher_name" = "match_reroute_output_dependency"]  
      
      // concat producer and consumer operands
      %consumer_operands : !range<!value> = irutils.get_operands(%fst_consumer : !operation)
      %producer_operands : !range<!value> = irutils.get_operands(%producer : !operation)
      %new_operands : !range<!value> = irutils.concat(%consumer_operands : !range<!value>, %producer_operands : !range<!value>)

      %fst_consumer_args : !range<!value> = irutils.get_block_args(%fst_consumer : !operation)
      %producer_results : !range<!value> = irutils.get_results(%producer : !operation)
      %additional_block_args : !range<!value> = irutils.new_block_args(%producer_results : !range<!value>)
      %new_block_args : !range<!value> = irutils.concat(%fst_consumer_args : !range<!value>, %additional_block_args : !range<!value>)

      // computing of new bounds
      %fst_consumer_attributes : !range<!attribute> = irutils.get_attributes(%fst_consumer : !operation)

      %producer_lb : !attribute = irutils.get_attribute(%producer : !operation) ["attr_name" = "lb"]
      %producer_ub : !attribute = irutils.get_attribute(%producer : !operation) ["attr_name" = "ub"]
      %fst_consumer_lb : !attribute = irutils.get_attribute(%fst_consumer : !operation) ["attr_name" = "lb"]
      %fst_consumer_ub : !attribute = irutils.get_attribute(%fst_consumer : !operation) ["attr_name" = "ub"]

      %new_lb_attr : !attribute = irutils.array_attr_element_wise(%producer_lb : !attribute, %fst_consumer_lb : !attribute) ["op" = "min"]
      %new_ub_attr : !attribute = irutils.array_attr_element_wise(%producer_ub : !attribute, %fst_consumer_ub : !attribute) ["op" = "max"]

      %new_attributes : !range<!attribute> = irutils.attribute_range(%fst_consumer_attributes : !range<!attribute>, %new_lb_attr : !attribute, %new_ub_attr : !attribute) ["attribute_names"=["lb", "ub"]]

      // computing new result type
      %result_shape : !attribute = irutils.array_attr_element_wise(%new_ub_attr : !attribute, %new_lb_attr : !attribute) ["op" = "sub"]
      %result_type : !type = irutils.construct_type(%result_shape : !attribute) ["name" = "stencil.TempType"]

      // incomplete from here, actual construction of the new ops is missing



      rewrite.return(%fst_consumer : !operation)
    }

  }



  ////////////////////////////////////////////////////////////////////////////////
  //     Register native strategies (which were already defined in Python)      //
  ////////////////////////////////////////////////////////////////////////////////

  %garbage_collect : !strategy = elevate.native() ["strategy_name"="garbage_collect"]
  %remove_unused_apply_operands : !strategy = elevate.native() ["strategy_name"="remove_unused_apply_operands"]
  %remove_duplicate_apply_operands : !strategy = elevate.native() ["strategy_name"="remove_duplicate_apply_operands"]
  
  ////////////////////////////////////////////////////////////////////////////////
  //          Define strategies as compositions of other strategies             //
  ////////////////////////////////////////////////////////////////////////////////


  %stencil_normal_form : !strategy = elevate.compose() ["strategy_name"="stencil_normal_form"] {
    elevate.everywhere() {
        elevate.apply(%remove_unused_apply_operands : !strategy)
    }
    elevate.everywhere() {
        elevate.apply(%remove_duplicate_apply_operands : !strategy)
    }
  }

  // inlining
  %basic_inlining_simplified : !strategy = elevate.compose() ["strategy_name"="basic_inlining_simplified"] {
    elevate.everywhere() {
        elevate.apply(%stencil_normal_form : !strategy)
        elevate.apply(%inline_simplified : !strategy)
        elevate.apply(%stencil_normal_form : !strategy)
    }
    elevate.toptobottom() {
        elevate.apply(%garbage_collect : !strategy)
    }
    elevate.toptobottom() {
        elevate.apply(%garbage_collect : !strategy)
    }
  }

  // inlining
  %basic_inlining : !strategy = elevate.compose() ["strategy_name"="basic_inlining"] {
    elevate.everywhere() {
        elevate.apply(%stencil_normal_form : !strategy)
        elevate.apply(%inline : !strategy)
        elevate.apply(%stencil_normal_form : !strategy)
    }
    elevate.toptobottom() {
        elevate.apply(%garbage_collect : !strategy)
    }
  }

  // reroute
  %reroute_output_dep : !strategy = elevate.compose() ["strategy_name"="reroute_output_dep"] {
    // elevate.toptobottom() {
      elevate.apply(%reroute : !strategy)
    // }
  }
}
